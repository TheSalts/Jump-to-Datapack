마인크래프트의 동적 구성 요소 중 하나인 엔티티(`entity`)를 최적화 하는 방법에 대해 설명합니다.

<br/>

엔티티(`entity`)는 그 의미처럼 움직이거나(`Pos`), 어딘가를 바라보거나(`Rotation`), 살아(`Health`) 있습니다.  
그리고 마인크래프트를 플레이 하는 플레이어 또한 엔티티입니다.

엔티티는 고유한 데이터인 NBT(`Named Binary Tag`)를 가집니다. 모든 엔티티가 가지는 NBT(`Pos`, `Air`)와 특정 엔티티가 가지는 NBT(`Inventory`, `Sitting`)가 있으며, 엔티티의 유형에 따라 전체 `NBT`의 개수가 다르며 어떠한 클래스의 상속을 받았는지에 따라 부모 클래스의 `NBT`도 포함하므로 전체적인 `NBT`가 늘어나게 됩니다.
- 엔티티 상속(`inheritance`)에 대한 것은 [[:paper: 01-10-1 엔티티 대표 클래스](#2/01-10-1)] 페이지를 확인하십시오.

---

# minecraft:marker
`표지`는 마인크래프트에서 가장 적은 비용을 소모하는 엔티티입니다.

[[:snapshot: <span style="font-family:Minecraft-Event"/> Minecraft 21w15a](https://minecraft.wiki/w/Java_Edition_21w15a)(1.17 스냅샷)] 때, 추가되어 별도의 사용자 지정 가능한 NBT인 `data`를 선두로 가벼운 성능에 가장 큰 초점을 맞추어 맵 제작자 및 데이터 팩과 명령어로 컨텐츠를 만드는 사람들에게 요긴하게 사용됩니다.

표지의 가벼운 성능에는 다음 특징이 그 이유가 됩니다.
- 엔티티의 모델이 없습니다.
   - 클라이언트 부담이 없으며, 히트박스 또한 없으므로 충돌 연산을 하지 않습니다.
   - 많을수록 `FPS`를 감소시키는 다른 엔티티와는 달리 그 하강세가 적습니다.
- 패킷 송수신을 최소화합니다.
   - 클라이언트와 서버가 동기화 할 데이터가 없으므로, 송수신 되는 양이 적습니다.
   - `Passengers` NBT가 적용되지 않으므로 `Passengers`에 대한 패킷 또한 없습니다.
   - <details class="details">
      <summary><span/>송수신이 되지 않는 <code>Packet</code></summary>

      `add_entity`, `move_entity_pos`, `move_entity_pos_rot`, `entity_position_sync`, `set_entity_data`

      <br/>

      단, `set_passengers`는 송신합니다.
      - [[:mojang: MC-276284](https://bugs.mojang.com/browse/MC/issues/MC-276284)]
      </details>

   - <details class="details">
      <summary><span/>별도의 행동이 없습니다</summary>

      ```java
      public void tick() {   }
      ```
      </details>

   - <details class="details">
      <summary><span/><code>NBT</code>의 전체 수가 적습니다</summary>

      > `Pos`, `Motion`, `Rotation`, `FallDistance`, `Fire`, `Air`, `OnGround`, `Invulnerable`, `PortalCooldown`, `UUID`, `CustomName`, `CustomNameVisible`, `Silent`, `NoGravity`, `Glowing`, `TicksFrozen`, `HasVisualFire`, `Tags`, `data`

      전체 nbt가 늘어날수록 NBT에 접근하는 명령어(`if data entity` / `@s[nbt={}]`, `/data` 등)의 성능이 저하됩니다.
      </details>

<br/>

### 이외의 엔티티
다음 엔티티들도 표지 대용으로 사용할 수 있습니다.
- 주로 `Passengers` 목적

| 엔티티 | 참고 사항 |
|-------|-----------|
| marker | nbt 기본값 |
| interaction | `{width: 0f, height: 0f}` |
| text_display | nbt 기본값 |
| item_display | `{item:{id:"minecraft:air"}}` |

<br/>

# nbt
모든 엔티티는 해당 엔티티의 행동 및 기본 상태를 저장하기 위해 `NBT` 데이터를 가지며,
이러한 데이터를 다루는 명령어인 `/data`(및 모든 `NBT` 접근 명령어)는 엔티티의 `NBT`에 직접 접근하여 값을 변경하거나 읽을 수 있습니다.

그러나, `/data`(및 모든 `NBT` 접근 명령어)는 내부적으로 큰 연산 비용이 드는 명령어입니다.
<details class="details">
<summary><span/>saveWithoutId()</summary>

```java
public void saveWithoutId(ValueOutput valueoutput) {
   /* 필수 */
   try {
      if (this.vehicle != null) {
         valueoutput.store("Pos", Vec3.CODEC, new Vec3(this.vehicle.getX(), this.getY(), this.vehicle.getZ()));
      } else {
         valueoutput.store("Pos", Vec3.CODEC, this.position());
      }
      valueoutput.store("Motion", Vec3.CODEC, this.getDeltaMovement());
      valueoutput.store("Rotation", Vec2.CODEC, new Vec2(this.getYRot(), this.getXRot()));
      valueoutput.putDouble("fall_distance", this.fallDistance);
      valueoutput.putShort("Fire", (short)this.remainingFireTicks);
      valueoutput.putShort("Air", (short)this.getAirSupply());
      valueoutput.putBoolean("OnGround", this.onGround());
      valueoutput.putBoolean("Invulnerable", this.invulnerable);
      valueoutput.putInt("PortalCooldown", this.portalCooldown);
      valueoutput.store("UUID", UUIDUtil.CODEC, this.getUUID());
      valueoutput.storeNullable("CustomName", ComponentSerialization.CODEC, this.getCustomName());

   /* 선택적 */
      if (this.isCustomNameVisible()) {
         valueoutput.putBoolean("CustomNameVisible", this.isCustomNameVisible());
      }
      if (this.isSilent()) {
         valueoutput.putBoolean("Silent", this.isSilent());
      }
      if (this.isNoGravity()) {
         valueoutput.putBoolean("NoGravity", this.isNoGravity());
      }
      if (this.hasGlowingTag) {
         valueoutput.putBoolean("Glowing", true);
      }
      int i = this.getTicksFrozen();
      if (i > 0) {
         valueoutput.putInt("TicksFrozen", this.getTicksFrozen());
      }
      if (this.hasVisualFire) {
         valueoutput.putBoolean("HasVisualFire", this.hasVisualFire);
      }
      if (!this.tags.isEmpty()) {
         valueoutput.store("Tags", TAG_LIST_CODEC, List.copyOf(this.tags)); // O(N): 태그 개수에 비례, 코덱화로 인한 성능 저하
      }
      if (!this.customData.isEmpty()) {
         valueoutput.store("data", CustomData.CODEC, this.customData); // 모든 엔티티의 NBT가 한 개 더 증가
      }

      this.addAdditionalSaveData(valueoutput); // 각 엔티티마다 필요한 NBT 저장

      if (this.isVehicle()) {
         ValueOutput.ValueOutputList valueoutput_valueoutputlist = valueoutput.childrenList("Passengers");
         Iterator var9 = this.getPassengers().iterator();

         while(var9.hasNext()) {
            Entity entity = (Entity)var9.next();
            ValueOutput valueoutput1 = valueoutput_valueoutputlist.addChild();
            if (!entity.saveAsPassenger(valueoutput1)) {
               valueoutput_valueoutputlist.discardLast();
            }
         }

         if (valueoutput_valueoutputlist.isEmpty()) {
            valueoutput.discard("Passengers");
         }
      }

   } catch (Throwable var7) {
      CrashReport crashreport = CrashReport.forThrowable(var7, "Saving entity NBT");
      CrashReportCategory crashreportcategory = crashreport.addCategory("Entity being saved");
      this.fillCrashReportCategory(crashreportcategory);
      throw new ReportedException(crashreport);
   }
}
```
</details>

- 사용 위치
   - [[nbt predicate](https://minecraft.wiki/w/Predicate#JSON_format)]
   - [[/data ... entity](https://minecraft.wiki/w/Commands/data)]
   - [[/execute if data entity](https://minecraft.wiki/w/Commands/execute#(if|unless)_data)]
   - [[nbt={}](https://minecraft.wiki/w/Target_selectors#Selecting_targets_by_nbt)]
      - `nbt=`의 경우 다음과 같이 중첩하여 사용하면 성능 저하가 더욱 심해집니다.  
         [[:mojang: MC-257155](https://bugs.mojang.com/browse/MC/issues/MC-257155)]
         ```mcfunction
         execute if entity @s[nbt={}, nbt={}]
         ```
   - 싱글, 랜서버에서 세계 저장 시(플레이어 데이터)
   - [[F3 + I](https://minecraft.wiki/w/Debug_hotkey#List_of_debug_hotkeys)]
   - 차원 간의 이동 시
   - 길들인 앵무새를 어깨에 올릴 때
   - 엔티티를 아이템으로 생성할 때(`boat`, `minecart`, `item_frame`, `glow_item_frame`, `painting`, `entity_bucket`)

<details class="details">
<summary><span/>플레이어의 SelectedItem</summary>

플레이어의 경우, 주로 사용하는 손에 아이템(`SelectedItem`)을 들고 있다면, 들고 있지 않을 때와 비교하여 성능의 차이가 발생하는데 `components`의 수(전체 데이터)가 많아질수록 증가합니다.

`SelectedItem`은 세계에 저장되는 데이터가 아니고, `SelectedItemSlot`과 `Inventory`를 이용해서 기존 `nbt`에 코드 내부적으로 추가하는 형태입니다.
```java
if (entity instanceof Player player) { // Player 대신 ServerPlayer를 사용하기도 함
   ItemStack item = player.getInventory().getSelectedItem(); // 인벤토리에서 SelectedItemSlot을 인덱스로 사용
   if (!item.isEmpty()) {
      tagvalueoutput.store("SelectedItem", ItemStack.CODEC, item); // SelectedItem을 추가하여 저장
   }
}
public ItemStack getSelectedItem() {
   return (ItemStack)this.items.get(this.selected);
}
```
</details>

<br/>

따라서, 가능한 한 `/data`를 직접 사용하는 횟수를 줄이고, 동일한 효과를 더 빠르게 구현할 수 있는 다른 명령어를 사용하는 것이 좋습니다.

| nbt | 명령어 | 엔티티 |
|-----|--------|--------|
| `attributes` | /attribute | LivingEntity |
| `active_effects` | /effect | LivingEntity |
| `Inventory`, `SelectedItem`, `equipment` | /clear, /give | 플레이어 |
| `Inventory`, `SelectedItem`, `equipment` | /item, /loot | LivingEntity, 화살, 분광 화살, 상자가 실린 보트, 상자가 실린 광산 수레, 호퍼가 실린 광산 수레, 아이템 표시, 화염구, 작은 화염구, 아이템, 아이템 액자, 발광 아이템 액자 |
| `Rotation` | /rotate | 모든 엔티티 |
| `air`, `food`, `health`, `level`, `xp` | /scoreboard | LivingEntity |
| `Tags` | /tag | 모든 엔티티 |
| `Team` | /team | 모든 엔티티 |
| `Pos`, `Motion`, `Rotation` | /tp | 모든 엔티티 |

<br/>

# predicate
[[:minecraft: <span style="font-family:Minecraft-Event"/> Minecraft 19w38a](https://minecraft.wiki/w/Java_Edition_19w38a)(1.15 스냅샷)]에서 추가된 조건으로 게임 내에서 엔티티/블록 및 기타 행동과 상태를 판단하는 기능을 제공합니다. **JSON**(`@s[predicate=]` | `execute if predicate`) 또는 **SNBT**(`execute if predicate`) 형식으로 작성됩니다.
- 자세한 내용은 [[:paper: 03-1 술어란?](#1/03-1)] 페이지를 참고하십시오.

예를 들어, 엔티티가 특정 아이템을 들고 있는지, 특정 포션 효과가 걸려 있는지, 혹은 특정 블록 위에 있는지 등을 검사할 수 있습니다. 이를 통해 더 복잡한 명령어 로직을 구성할 수 있고, 비용도 줄일 수 있습니다.

`nbt`로만 감지할 수 있었던 특정 조건 또한 `predicate`로 일부 대체할 수 있습니다.

| nbt | predicate | 엔티티 |
|-----------|-----|--------|
| `recipeBook.recipes` | recipes | 플레이어
| `Sheared` | sheared | 양 |
| `Size` | size | 슬라임
| `Fire` | is_on_fire | LivingEntity |
| `IsBaby` | is_baby | LivingEntity |
| `OnGround` | is_on_ground | 모든 엔티티 |
| `FallFlying`, `abilities.flying` | is_flying | LivingEntity, 플레이어 |
| `RootVehicle` | vehicle | 플레이어 |
| `Passengers` | passengers | 거의 대부분의 엔티티 |
| `active_effects` | effects | LivingEntity |
| `data` | components, predicates | 모든 엔티티 | 

특히, 사용자 지정 데이터를 저장할 수 있는 `data` NBT는 `predicate`에서 조건을 감지하는편이 `NBT`를 직접적으로 감지하는 것보다 2배 이상 낫습니다.