명령어 사용 시 필연적인 선택자(`target selector`)를 최적화 하는 방법에 대해 설명합니다.

<br/>

선택자에 대한 내용은 [[:paper: 01-3 선택자](#2/01-3)]을 참고하십시오.

## 기본 선택자

<details class="details">
   <summary><span/>@e, @n</summary>

   플레이어 포함 다른 엔티티를 선택하는 `@e`, `@n`의 경우, 해당 엔티티가 살아 있는지 확인합니다.

   따라서, `@e[type=player]`와 `@a` / `@n[type=player]`와 `@p`의 성능 차이가 발생합니다.

   ```java
   public boolean isAlive() {
      return !this.isRemoved();
   }


   @Override
   public final boolean isRemoved() {
      return this.removalReason != null;
   }
   ```
</details>

<br/>

# 인수
## limit
- 값: `int`

선택 가능한 엔티티의 수를 제한합니다.
엔티티가 많은 상황에서는 성능을 향상시킵니다.

예를 들어, 명령 실행 조건이 '세계에 아무 엔티티나 한 개체 있어야 한다'라면,  
`/execute if entity @e` 보다는 `/execute if entity @e[limit=1]` 명령어가 더 낫습니다.

엔티티의 필터링이 끝나고 최종적으로 배열에 엔티티를 추가할 때, `Integer.MAX_VALUE` 즉, 찾을 수 있는 모든 엔티티를 전부 순회합니다.  
`limit` 인수를 작성하면 엔티티 확인을 조기 종료할 수 있기에 작성하지 않은 구문보다 가볍게 동작합니다.

<br/>

## type
- 값: `entity type`

특정 엔티티 유형을 가진 엔티티를 필터링합니다.
엔티티의 종류가 많은 상황에서는 성능을 향상시킵니다.

단, `type`은 총 `2`번 확인되고, 다른 인수에 비해 가볍습니다. (미소한 최적화)  
`#`과 `!`, `!#`로 시작하는 엔티티 유형은 예외입니다.

<details class="details">
<summary><span/>실험</summary>

   세계에 늑대 4마리와 고양이 4마리가 있다고 가정한다.  
   늑대 2마리와 고양이 2마리에게 각각 `a` 태그가 존재한다.

   ```mcfunction
   # 1번
   @e[tag=a, type=wolf]

   # 2번
   @e[type=wolf, tag=a]
   ```

   1번: `type` -> `tag` -> `type`  
   2번: `type` -> `type` -> `tag`

   1번의 연산량: 10(`type`) + 4(`tag`)  
   2번의 연산량: 12(`type`) + 4(`tag`)
</details>

<br/>

## d/xyz
- 값: `double`

엔티티의 히트박스를 기준으로 사각형 범위를 생성합니다.
엔티티가 서로 떨어져 있는 상황에서는 성능을 향상시킵니다.

단, 엔티티가 서로 한 곳에 모여 있으면 범위 내에 포함되는 엔티티의 수가 많아지므로 성능이 저하됩니다.  
범위가 매우 커지면 성능이 저하됩니다.

<br/>

## distance
- 값: `양의 double`

엔티티의 히트박스 중앙 하단을 기준으로 구형의 범위를 생성합니다.
엔티티가 서로 떨어져 있는 상황에서는 성능을 향상시킵니다.

단, 엔티티가 서로 한 곳에 모여 있으면 범위 내에 포함되는 엔티티의 수가 많아지므로 성능이 저하됩니다.  
범위가 매우 커지면 성능이 저하됩니다.

<br/>

## tag
- 값: `string`

엔티티의 문자열 목록인 태그를 확인합니다.
특정 태그를 가진 엔티티의 수가 전체 엔티티보다 적을 때 성능을 향상시킵니다.

단, 모든 엔티티가 같은 태그를 가지고 있으면 성능이 저하됩니다.

<br/>

## team
- 값: `string`

엔티티가 속한 팀의 이름을 확인합니다.
특정 팀에 속한 엔티티의 수가 전체 엔티티보다 적을 때 성능을 향상시킵니다.

단, 모든 엔티티가 같은 팀에 속해 있으면 성능이 저하됩니다.

<br/>

## scores
- 값: `int`

엔티티가 보유한 점수를 확인합니다.
특정 점수를 보유한 엔티티의 수가 전체 엔티티보다 적을 때 성능을 향상시킵니다.

단, 모든 엔티티가 점수를 보유하고 있다면 성능이 저하됩니다.

<br/>

## sort
- 값: `sort type`

엔티티의 정렬 기준을 변경합니다.
작성하지 않거나 `arbitrary` 기준일 때 성능이 향상됩니다.
- [[:minecraft: <span style="font-family:Minecraft-Event"/> Minecraft 1.19.3](https://www.minecraft.net/en-us/article/minecraft-java-edition-1-19-3)] 버전에서 추가되었습니다.

`nearest`와 `furthest`는 선택된 모든 엔티티와 거리 계산을 하기에 많은 성능이 저하됩니다.  
`random`은 선택된 모든 엔티티를 섞지만, 거리 계산보다 비용은 적습니다.
그래도 성능을 저하시킵니다.

<br/>

## name
- 값: `string`

엔티티의 이름(`CustomName`)을 확인합니다.

<br/>

## predicate
- 값: `Compound`

엔티티의 속성을 확인합니다.  
`NBT`를 이용해 엔티티의 `nbt`를 확인하면 `nbt=` 인수와 성능이 비슷하거나 더욱 저하됩니다.

`@s` 선택자의 경우에도 `predicate=` 인수를 사용할 수 있습니다.  
그러나, 이 때는 `/execute if/unless predicate`를 이용해 감지하는 편이 더 적은 비용을 소모합니다.
```mcfunction
execute if entity @s[predicate=test:test]

-->

execute if predicate test:test
```

이외의 선택자의 경우(`@a`, `@e` 등)에는 선택자에 압축시키는 방식이 더 적은 비용을 소모합니다.
```mcfunction
execute as @e if predicate test:test

-->

execute as @e[predicate=test:test]
```

<br/>

## nbt
- 값: `Compound`

엔티티의 `nbt`를 확인합니다. 성능을 매우 저하시킵니다.  
자세한 내용은 [[:paper: 04-2 엔티티](#2/04-2)] 페이지를 참고하십시오.

---

# 인수 배치
마인크래프트는 인수를 어떤 순서로 배치하느냐에 따라 성능 차이가 발생합니다.  
주로 많은 엔티티를 적은 비용으로 필터링 할 수 있는 인수를 앞에 배치합니다.

### 예외 사항
- `limit`과 `sort`는 어느 위치에 있든 항상 맨 마지막으로 확인합니다.
- 가능하다면 `x/y/z`는 `execute positioned`를 사용할 수 있습니다.
- `distance`, `d/xyz`는 배치 순서에 영향을 받지 않지만, 범위를 매우 크게 설정할 경우, 매우 성능이 저하됩니다.

1. team
2. tag
4. scores
5. name
6. nbt<sup/>`[1]`
7. predicate<sup/>`[2]`
8. type<sup/>`[3]`

`[1]`: `nbt` 인수는 맨 앞에 삽입될 경우 매우 성능이 저하됩니다.  
`[2]`: `predicate` 인수는 맨 앞에 삽입될 경우 매우 성능이 저하됩니다.  
`[3]`: `type` 인수는 2번 확인되기에 중복 확인을 피하기 위해 맨 뒤에 삽입하며, `type=!`, `type=#`은 제외됩니다.