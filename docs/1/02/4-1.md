- [[:paper: 02-4 재귀함수](#1/02-4)] 글을 읽고 오는 것을 추천드립니다.

<br/>

레이캐스팅(`ray-casting`)은 어떤 점에서 특정 방향으로 광선을 쏘고, 그 광선이 어떤 객체와 충돌하는지 계산하는 기법입니다.

주로 활용되는 장르는 `FPS`로 과거에는 `2D` 화면에서 `3D` 화면 렌더링을 위해 레이캐스팅이 사용되었습니다. (그때의 PC 성능은 지금처럼 좋지 못했습니다)

그리고 이러한 개념은 마인크래프트에도 적용할 수 있으며, 레이캐스팅 기법을 응용할 수 있는 곳이 굉장히 많습니다.

예를 들어, 다음 기능을 구현할 수 있습니다.
- 총기 히트스캔
- 바라보고 있는 엔티티 확인
- 바라보고 있는 블록 확인
- 발사체
- 빛과 그림자 계산
- ...

<br/>

우선 레이캐스팅은 재귀함수를 통해 구현됩니다.

[[:paper: 02-4 재귀함수](#1/02-4)] 페이지 하단에 `y0.0`에서 `y1.0`까지 `dust` 입자를 표시하는 예시 구문을 확인할 수 있는데,

이때, `execute positioned ~ ~.125 ~ run function <this>` 명령어로 `n`번 동안 `n * 0.125` 만큼의 좌표가 더해졌단 것을 알 수 있습니다.

이렇듯 가장 일반적인 방법은 재귀함수를 사용하는 것입니다.

---

<br/>

# 재귀함수를 이용한 레이캐스팅
먼저, 어떤 점은 플레이어의 시선 위치로 방향은 플레이어가 바라보는 방향으로 정의하고, 구현하겠습니다.

플레이어의 시선 위치로 올리기 위해 `positioned ~ ~1.62 ~`를 사용합니다.
```mcfunction
execute as @a at @s positioned ~ ~1.62 ~
```

<details class="details">
   <summary><span/>anchored eyes 오차</summary>

   `anchored eyes`를 사용해도 좋지만, `double + float`로 인해 오차가 발생합니다.

   일반적으로 엔티티의 히트박스와 눈높이는 `float` 형식으로  
   좌표(`Pos`)는 `double` 형식으로 저장되는데,

   ```java
   /** 플레이어의 히트박스 */
   public static final EntityType<Player> PLAYER = register(
      "player",
      EntityType.Builder.<Player>createNothing(MobCategory.MISC)
         .noSave()
         .noSummon()
         .sized(0.6F, 1.8F)
         .eyeHeight(1.62F)
         .vehicleAttachment(Player.DEFAULT_VEHICLE_ATTACHMENT)
         .clientTrackingRange(32)
         .updateInterval(2)
   );
   ```

   `anchored eyes`는 `좌표 + 눈높이`로 구현되기에 오차가 발생합니다.

   대략, `0.0000000047683716`(4.7683716×10^-9)로  
   따라서, 눈높이는 `positioned ~ ~1.62 ~`를 이용해 오차를 보정합니다.
</details>

<br/>

시선 방향 벡터를 얻어내기 위해, `^ ^ ^` 좌표를 사용합니다.

`^ ^ ^`를 사용하면 현재 시선을 기준으로 벡터를 계산합니다.

`^ ^ ^1`는 현재 시선을 기준으로 한 칸 앞이며,  
`^1 ^ ^`는 현재 시선을 기준으로 왼쪽으로 한 칸 옆입니다.

```mcfunction
execute as @a at @s positioned ~ ~1.62 ~ positioned ^ ^ ^ run function ray:ready
```

<br/>

다음으로 광선의 최대 거리와 부딪힘 여부를 지정해야 합니다.  
즉, 재귀함수의 종료 지점을 설정해야 합니다.

설정하지 않으면, 쓸데없이 `65,536`번 함수가 실행될 것입니다.  
불필요한 연산을 없애기 위해 제한량을 스코어 보드로 설정합니다.

```mcfunction
execute as @a at @s positioned ~ ~1.62 ~ positioned ^ ^ ^ run function ray:ready


# ray:ready
   scoreboard players set #re_count ray 50
   scoreboard players set #if ray 0

   function ray:start
```

`50` = 최대 거리를 `5`블록으로 제한
또한,
```mcfunction
attribute @s minecraft:block_interaction_range get 10
```
으로 현재 블록 상호 작용 범위를 최대 범위에 적용할 수도 있습니다.

<br/>

`ray:start` 함수에는 다음 항목이 포함되어야 합니다.
- 부딪힘 성공 조건
- 반복 조건

예를 들어,
- 성공 조건이 `유리 블록에 부딪힘`
- 반복 조건이 `부딪힘이 일어나지 않음`

다음과 같이 코드를 작성할 수 있습니다.
```mcfunction
execute as @a at @s positioned ~ ~1.62 ~ positioned ^ ^ ^ run function ray:ready


# ray:ready
   scoreboard players set #re_count ray 50
   scoreboard players set #if ray 0

   function ray:start


# ray:start
   scoreboard players remove #re_count ray 1

   # 유리 블록에 부딪힘
   execute if block ~ ~ ~ glass run function ray:success

   # 부딪힘이 일어나지 않음
   execute if score #if ray matches 0 if score #re_count ray matches 1.. positioned ^ ^ ^.1 run function ray:start


# ray:success
   scoreboard players set #if ray 1

   particle flame
```

   <video width="640" height="360" controls>
     <source src="assets/vid/02-4-1/raycast.mp4" type="video/mp4">
   </video>

일반적으로 정밀도 `0.1`을 기준으로 레이캐스팅을 구현합니다.

`positioned ^ ^ ^.1` `0.1`칸 씩 앞으로 이동하기 때문에 최대 정밀도는 `0.1`입니다.  
이 값을 줄이면 더욱 정밀한 레이캐스팅이 가능하지만, 연산량이 많아져야 하므로 성능이 저하될 수 있습니다.

`0.01`칸 씩 앞으로 이동한다면, 최대 범위를 `5`블록으로 제한할 때, 틱당 `500`번 함수를 작동해야 합니다.

<br/>

광선의 경로를 표시하고 싶으면 `start` 함수에 다음 명령어를 추가합니다.
```diff
+ particle end_rod
```

```mcfunction
# ray:start
   scoreboard players remove #re_count ray 1

   # 경로 표시
   particle end_rod

   # 유리 블록에 부딪힘
   execute if block ~ ~ ~ glass run function ray:success

   # 부딪힘이 일어나지 않음
   execute if score #if ray matches 0 if score #re_count ray matches 1.. positioned ^ ^ ^.1 run function ray:start
```

   <video width="640" height="360" controls>
     <source src="assets/vid/02-4-1/raycast_way.mp4" type="video/mp4">
   </video>

또한, 이 방법은 유리 블록이 있으면 반복이 종료되어, 가장 가까이 있는 유리 블록이 선택됩니다.

---

<br/>

> <span style="color:red"/>주의</span>: 아래 설명은 입문자와 중급자에게는 적절하지 않습니다.

<details class="details">
<summary><span/>명령어를 이용한 레이캐스팅</summary>

`execute` 명령어 인수 중, `as`/`facing`/`rotated` 등과 같은 [[:paper: 01-1 컨텍스트](#2/01-1)]는 `n` 개의 엔티티만큼 실행합니다.

그렇다면, 엔티티만큼 명령어를 실행한다는 특징을 레이캐스팅에 이용해 볼 수 있습니다.

우선 현재 플레이어가 바라보고 있는 방향의 엔티티와 반대 방향으로 바라보고 있는 엔티티가 필요합니다.
```mcfunction
execute in minecraft:overworld run forceload add 0 0

execute in minecraft:overworld run summon marker 0. 0 0. {Tags:[rays],UUID:[I;0,0,0,0]}
execute in minecraft:overworld run summon marker 0. 0 0. {Tags:[rays],UUID:[I;0,0,0,1]}


execute rotated as PLAYER run function ray:rotate

# ray:rotate
   # 동일 시선
      rotate 0-0-0-0-0 ~ ~
   # 역방향
      execute facing ^ ^ ^-1 run rotate 0-0-0-0-1 ~ ~
```

그리고 `rotated`를 사용하여 다음 명령어를 실행합니다.
```mcfunction
execute as @a at @s positioned ~ ~1.62 ~ rotated as @e[limit=2,tag=rays,type=marker] positioned ^ ^ ^2 run ...
```

그럼 다음 이미지와 같은 위치로 컨텍스트가 복사되고 이동합니다.  
![rotated](assets/img/docs/rotated.png)

이렇게 범위를 0.125까지 줄여나가면 레이캐스팅 비슷한 무언가를 만들 수 있습니다.
```mcfunction
execute as @a at @s positioned ~ ~1.62 ~ positioned ^ ^ ^8 rotated as @e[limit=2,tag=rays,type=marker] positioned ^ ^ ^4 rotated as @e[limit=2,tag=rays,type=marker] positioned ^ ^ ^2 rotated as @e[limit=2,tag=rays,type=marker] positioned ^ ^ ^1 rotated as @e[limit=2,tag=rays,type=marker] positioned ^ ^ ^.5 rotated as @e[limit=2,tag=rays,type=marker] positioned ^ ^ ^.25 rotated as @e[limit=2,tag=rays,type=marker] positioned ^ ^ ^.125 run ...
```
![rotated1](assets/img/docs/rotated_0125.png)

단점으로는 앞의 블록을 뚫어 버립니다.  
![rotated2](assets/img/docs/rotated_block.png)

유리 블록이 있는 곳에 명령어를 실행하려면 다음 조건을 추가하면 됩니다.
```diff
+ if block ~ ~ ~ glass run ...
```
```mcfunction
execute as @a at @s positioned ~ ~1.62 ~ positioned ^ ^ ^8 rotated as @e[limit=2,tag=rays,type=marker] positioned ^ ^ ^4 rotated as @e[limit=2,tag=rays,type=marker] positioned ^ ^ ^2 rotated as @e[limit=2,tag=rays,type=marker] positioned ^ ^ ^1 rotated as @e[limit=2,tag=rays,type=marker] positioned ^ ^ ^.5 rotated as @e[limit=2,tag=rays,type=marker] positioned ^ ^ ^.25 rotated as @e[limit=2,tag=rays,type=marker] positioned ^ ^ ^.125 if block ~ ~ ~ glass run ...
```
</details>